package Unit05_sort;

/**
 * 快速排序
 * 比归并排序应用更广泛，因为归并不是原地排序。
 * 乍看起来，它有点像归并排序，但是思路其实完全不一样。
 * 如果要排序数组中下标从 p 到 r 之间的一组数据，我们选择 p 到 r 之间的任意一个数据作为 pivot（分区点）。
 * 我们遍历 p 到 r 之间的数据，将小于 pivot 的放到左边，将大于 pivot 的放到右边，将 pivot 放到中间。
 * 经过这一步骤之后，数组 p 到 r 之间的数据就被分成了三个部分，前面 p 到 q-1 之间都是小于 pivot 的，中间是 pivot，后面的 q+1 到 r 之间是大于 pivot 的。此时分区中的数据不一定有序。
 * 根据分治、递归的处理思想，我们可以用递归排序下标从 p 到 q-1 之间的数据和下标从 q+1 到 r 之间的数据，直到区间缩小为 1，就说明所有的数据都有序了。
 *
 * 快速排序实现分解图
 * -----------------------填坑法---------------------
 * 原始数据： 4  7  6  5  3  2  8  1
 * 首先，我们选定基准元素Pivot，并记住这个位置index，这个位置相当于一个“坑”。并且设置两个指针left和right，指向数列的最左和最右两个元素：
 * 4(l,pivot)  7  6  5  3  2  8  1(r)
 * 从right指针开始，把指针所指向的元素和基准元素做比较。如果比pivot大，则right指针向左移动；如果比pivot小，则把right所指向的元素填入坑中。
 * 在当前数列中，1<4，所以把1填入基准元素所在位置，也就是坑的位置。这时候，元素1本来所在的位置成为了新的坑。同时，left向右移动一位。
 * 1(pivot)  7(l)  6  5  3  2  8  1(r)
 * 接下来，切换到left指针进行比较。如果left指向的元素小于pivot，则left指针向右移动；如果元素大于pivot，则把left指向的元素填入坑中。
 * 1(pivot)  7(l)  6  5  3  2  8  7(r)
 * 在当前数列中，7>4，所以把7填入index的位置。这时候元素7本来的位置成为了新的坑。同时，right向左移动一位。
 * ......
 * 以此类推
 *
 *  -----------------------指针法---------------------
 *  思路：
 *  选择最左端的为基准值（pivot）
 *  从右向左遍历，移动hi指针，找到第一个比基准值小的值。
 *  从左向右遍历，移动low指针，找到第一个比基准值大的值。
 *  交换此时low和hi指针位置的数值。这样左边那个大于key的值就被换到了右边，而右边那个比key小的值就被换到了左边。
 *  循环进行，直到low=hi
 *  low等于hi时,把基准值位置与low位置的数值互换。这样基准值就被换到了中间。
 *  原始数据： 4  7  6  5  3  2  8  1
 *  首先选定基准元素Pivot，并且设置两个指针left和right，指向数列的最左和最右两个元素：
 *  4(l,pivot)  7  6  5  3  2  8  1(r)
 *  第一次循环：
 *  从right指针开始，把指针所指向的元素和基准元素做比较。如果大于等于pivot，则指针向左移动，直到移动到小于pivot的；如果小于pivot，则right指针停止移动，切换到left指针。
 *  在当前数列中，1<4，所以right直接停止移动，换到left指针，进行下一步行动。
 *  轮到left指针行动，把指针所指向的元素和基准元素做比较。如果小于等于pivot，则指针向右移动，直到大于pivot的；如果大于pivot，则left指针停止移动。
 *  由于left一开始指向的是基准元素，判断肯定相等，所以left右移一位。
 *  继续比较，由于7 > 4，left指针在元素7的位置停下。这时候，我们让left和right指向的元素进行交换。
 *  4(pivot)  1(l)  6  5  3  2  8  7(r)
 *  第二次循环：
 *  重新切换到right向左移动。right先移动到8，大于pivot，移动到2，2小于pivot，停下，切换left指针。
 *  切换到left向右移动，此时6大于pivot，停下，左右指针交换。
 *  4(pivot)  1()  2(l)  5  3  6(r)  8  7
 *  继续第三次循环：
 *  4(pivot)  1()  2  3(l)  5(r)  6  8  7
 *  第四次循环：
 *  重新切换到right向左移动，left = right，指针重合了，pivot与left交换。
 *  3  1  2  4(pivot)  5  6  8  7
 *  最后以pivot为中心，左右两个分区继续递归重复上述过程。
 *
 *  -----------------------选择交换法---------------------
 *  上述的方式代码实现都比较复杂，还有一种比较巧妙的方式。处理有点类似选择排序。
 *  我们通过游标 i 把 A[l…r-1]分成两部分。A[l…i-1]的元素都是小于 pivot 的，我们暂且叫它“已处理区间”，A[i…r-1]是“未处理区间”。
 *  我们每次都从未处理的区间 A[i…r-1]中取一个元素 A[j]，与 pivot 对比，如果小于 pivot，则将其加入到已处理区间的尾部，也就是 A[i]的位置。大于不动，继续找下一个。
 *  在数组某个位置插入元素，需要搬移数据，非常耗时。有一种处理技巧，就是交换，在 O(1) 的时间复杂度内完成插入操作。
 *  借助这个思想，只需要将 A[i]与 A[j]交换，就可以在 O(1) 时间复杂度内将 A[j]放到下标为 i 的位置。
 *  6(l,i,j)  11  3  9  8(pivot,r)
 *  6(l,i,j)  11  3  9  8(pivot,r)   6<8,加入已处理区间尾部，swap，因为i=j，所以数据不变
 *  6(l)  11(i,j)  3  9  8(pivot,r)  11>8,已处理区间不动，继续找下一下，no swap
 *  6(l)  11(i)  3(j)  9  8(pivot,r) j此时移动到3，3<8，A[i]与A[j] swap
 *  6(l)  3  11(i)  9(j)  8(pivot,r)  此时i后移一位，j后移一位，找下一个
 *
 *
 * 与归并排序实现思路对比：
 * 归并排序的处理过程是由下到上的，先分解为子问题，然后再合并。
 * 快排正好相反，它的处理过程是由上到下的，先分区，然后再分解成子问题。
 *
 * 是稳定排序算法么？ 否  交换时可能前面的会有换到后面去   eg: 4 1 2 6 6 3 8 5
 * 是原地排序么？  是  O(1)
 * 时间复杂度：
 * 分析同归并排序
 * T(1) = C；   n=1时，只需要常量级的执行时间，所以表示为C。
 * T(n) = 2*T(n/2) + n； n>1
 * 公式成立的前提是每次分区操作，我们选择的 pivot 都很合适，正好能将大区间对等地一分为二。但实际上这种情况是很难实现的。
 * 如果数组中的数据原来已经是有序的了，比如 1，3，5，6，8。如果我们每次选择最后一个元素作为 pivot，那每次分区得到的两个区间都是不均等的。
 * 我们需要进行大约 n 次分区操作，才能完成快排的整个过程。每次分区我们平均要扫描大约 n/2 个元素。
 * 这种情况下，快排的时间复杂度就从 O(nlogn) 退化成了 O(n^2)。
 * 不过 T(n) 在大部分情况下的时间复杂度都可以做到 O(nlogn)，只有在极端情况下，才会退化到 O(n2)。
 * 而且，我们也有很多方法将这个概率降到很低。
 *
 * 其实，递归的时间复杂度的求解方法除了递推公式之外，还有递归树。
 *
 * -----------------------优化快速排序---------------------
 * 快速排序在最坏情况下的时间复杂度是 O(n^2)，如何来解决这个“复杂度恶化”的问题呢？
 * 最快情况：如果数据原来是有序或者接近有序的，每次分区点都选择最后一个数据，时间复杂度就会退化为O(n^2)
 * 所以重点是怎样选择分区点：
 * 理想的分区点是：分区点在数据的中间
 * 分区算法：
 * 1. 三数取中法：
 * 从区间的首、尾、中间，分别取出一个数，然后对比大小，取这3个数中间值作为分区点。如果要排序的数组比较大，"三数取中"可能就不够了，要"五数取中""十数取中"
 * 2. 随机法
 * 每次从要排序的区间中，随机选择一个元素作为分区点
 *
 * -----------------------防止递归过深，堆栈溢出---------------------
 * 1. 限制递归深度
 * 2. 在堆上模拟实现一个函数调用栈，手动模拟递归压栈、出栈的过程，规避了系统栈大小的限制
 * TODO 实现下模拟栈
 *
 */
public class QuickSort {

    private final int[] arr;

    public QuickSort() {
        //this.arr = new int[]{7,5,6,10,3,9,1};
        this.arr = new int[]{2,2,4,7,7,8};
    }

    private void asc() {
        sort(this.arr,0,arr.length-1);
    }

    // 选择交换法
    private void sort(int[] arr, int startIndex,int endIndex) {
        if (startIndex>=endIndex) {
            return;
        }
        int i = partition(arr,startIndex,endIndex); // 中间段 分区点
        sort(arr,startIndex,i-1); // 排序左分区
        sort(arr,i+1,endIndex); // 排序右分区
    }

    private int partition(int[] arr, int startIndex,int endIndex) {

        int pValue = arr[endIndex]; // 基准值
        int i = startIndex; // 已处理区间临界点
        int j = i; // 取出比较的数据

        while (j < endIndex) {
            if (arr[j]>pValue) {
                // 大于继续找下一个
                j++;
            } else if (i == j){
                // 小于，放到已处理队列最后，因为这里当前数据就是最后，所以不需要交换了
                i++;
                j++;
            } else {
                // 小于等于，交换
                int temp = arr[j];
                arr[j++] = arr[i];
                arr[i++] = temp;
            }
        }

        // 基准值交换到中间
        arr[j] = arr[i];
        arr[i] = pValue;

        return i;
    }

    private void printAll() {
        StringBuilder sb = new StringBuilder();
        for (int i:arr) {
            sb.append(i).append("\t");
        }
        System.out.println(sb.toString());
    }

    public static void main(String[] args) {
        QuickSort quickSort = new QuickSort();
        quickSort.asc();
        quickSort.printAll();
    }
}
