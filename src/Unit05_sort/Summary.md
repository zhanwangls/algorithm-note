### 如何分析一个排序算法？

#### 执行效率

* 最好情况、最坏情况、平均情况时间复杂度，并且要指出对应的原始数据是什么样的

* 时间复杂度的系数、常数、低阶 

  时间复杂度反映的是数据规模 n 很大的时候的一个增长趋势，所以它表示的时候会忽略系数、常数、低阶。但是实际的软件开发中，我们排序的可能是 10 个、100 个、1000 个这样规模很小的数据，所以，在对同一阶时间复杂度的排序算法性能对比的时候，我们就要把系数、常数、低阶也考虑进来。

* 比较次数和交换（或移动）次数

  基于比较的排序算法的执行过程，会涉及两种操作，一种是元素比较大小，另一种是元素交换或移动。所以，如果我们在分析排序算法的执行效率的时候，应该把比较次数和交换（或移动）次数也考虑进去。

#### 内存消耗

针对排序算法的空间复杂度，我们还引入了一个新的概念，原地排序（Sorted in place）。原地排序算法，就是特指空间复杂度是 O(1) 的排序算法。

#### 稳定性

针对排序算法，我们还有一个重要的度量指标，稳定性。这个概念是说，如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。

为什么要考虑稳定性？

真正软件开发中，我们要排序的往往不是单纯的整数，而是一组对象，我们需要按照对象的某个 key 来排序。

比如说，我们现在要给电商交易系统中的“订单”排序。订单有两个属性，一个是下单时间，另一个是订单金额。如果我们现在有 10 万条订单数据，我们希望按照金额从小到大对订单数据排序。对于金额相同的订单，我们希望按照下单时间从早到晚有序。对于这样一个排序需求，我们怎么来做呢？

最先想到的方法是：我们先按照金额对订单数据进行排序，然后，再遍历排序之后的订单数据，对于每个金额相同的小区间再按照下单时间排序。这种排序思路理解起来不难，但是实现起来会很复杂。

借助稳定排序算法，这个问题可以非常简洁地解决。解决思路是这样的：我们先按照下单时间给订单排序，注意是按照下单时间，不是金额。排序完成之后，我们用稳定排序算法，按照订单金额重新排序。两遍排序之后，我们得到的订单数据就是按照金额从小到大排序，金额相同的订单按照下单时间从早到晚排序的。



### 算法分类

|          | 原地？  | 稳定？                  | 最好/最坏/平均                 | 排序思想 | 适用                 |
| -------- | ------- | ----------------------- | ------------------------------ | -------- | -------------------- |
| 冒泡排序 | 是      | 是                      | O(n) / O(n^2) / O(n^2)         | 基于比较 | 小数据规模           |
| 插入排序 | 是      | 是                      | O(n) / O(n^2) / O(n^2)         | 基于比较 | 小数据规模           |
| 选择排序 | 是      | 否                      | O(n^2) / O(n^2) / O(n^2)       | 基于比较 | 小数据规模           |
| 归并排序 | 否 O(n) | 是                      | O(nlogn) / O(nlogn) / O(nlogn) | 分治思想 | 大数据规模           |
| 快速排序 | 是      | 否                      | O(nlogn) / O(nlogn) / O(n^2)   | 分治思想 | 大数据规模           |
| 桶排序   | 否      | 是 根据桶内排序算法而定 | O(n)                           |          | 桶之间分布均匀       |
| 计数排序 | 否      | 是                      | O(n+k)    k是数据范围          |          | 数据范围小，特殊的桶 |
| 基数排序 | 否      | 是                      | O(dn)     d是维度              |          | 位之间有递进关系     |
| 堆排序   | 是      | 否                      | O(nlogn) / O(nlogn) / O(nlogn)|          |                   |



### 为什么插入排序比冒泡排序更受欢迎？

冒泡排序不管怎么优化，元素交换的次数是一个固定值，是原始数据的逆序度。

插入排序是同样的，不管怎么优化，元素移动的次数也等于原始数据的逆序度。

但是，从代码实现上来看，冒泡排序的数据交换要比插入排序的数据移动要复杂，冒泡排序需要 3 个赋值操作，而插入排序只需要 1 个 

```
冒泡排序中数据的交换操作：
if (a[j] > a[j+1]) { // 交换
   int tmp = a[j];
   a[j] = a[j+1];
   a[j+1] = tmp;
   flag = true;
}

插入排序中数据的移动操作：
if (a[j] > value) {
  a[j+1] = a[j];  // 数据移动
} else {
  break;
}
```

理论上，我们把执行一个赋值语句的时间粗略地计为单位时间（unit_time），然后分别用冒泡排序和插入排序对同一个逆序度是 K 的数组进行排序。用冒泡排序，需要 K 次交换操作，每次需要 3 个赋值语句，所以交换操作总耗时就是 3*K 单位时间。而插入排序中数据移动操作只需要 K 个单位时间。

实验，针对上面的冒泡排序和插入排序的 Java 代码，写一个性能对比测试程序，随机生成 10000 个数组，每个数组中包含 200 个数据，然后在机器上分别用冒泡和插入排序算法来排序，冒泡排序算法大约 700ms 才能执行完成，而插入排序只需要 100ms 左右就能搞定！

所以，虽然冒泡排序和插入排序在时间复杂度上是一样的，都是 O(n2)，但是如果我们希望把性能优化做到极致，那肯定首选插入排序。插入排序的算法思路也有很大的优化空间，比如"希尔排序"。



### TODO 基于链表的排序呢？



### 线性排序

桶排序、计数排序、基数排序。因为这些排序算法的时间复杂度O(n)是线性的，所以我们把这类排序算法叫作线性排序（Linear sort）。
线性排序对要排序的数据要求很苛刻，重点是掌握这些排序算法的适用场景。



### 如何实现一个通用的、高性能的排序函数

1. 线性排序算法的时间复杂度比较低，适用场景比较特殊。所以如果要写一个通用的排序函数，不能选择线性排序算法。
2. 如果对小规模数据进行排序，可以选择时间复杂度是 O(n^2) 的算法；如果对大规模数据进行排序，时间复杂度是 O(nlogn) 的算法更加高效。所以，为了兼顾任意规模数据的排序，一般都会首选时间复杂度是 O(nlogn) 的排序算法来实现排序函数。
3. 时间复杂度是 O(nlogn) 的算法有归并排序、快速排序、堆排序。堆排序和快速排序都有比较多的应用，比如 Java 语言采用堆排序实现排序函数，C 语言使用快速排序实现排序函数。

举例：C语言中的qsort()

优先使用归并排序，对于小数据量的排序，可以空间O(n)换时间O(nlogn)；

数据量大时，改用快速排序，使用”三数取中“法选取分区点。通过自己实现一个堆上的栈，模拟递归解决递归堆栈溢出问题。

快速排序过程中，当要排序的区间中元素个数小于等于4，就退化为插入排序，选择不再用递归的排序，因为在小规模数据面前O(n^2)时间复杂福并不一定比O(nlogn)执行时间长，因为时间复杂度是忽略了常量、低阶、系数的，而小规模下，这些是会带来比较大的影响的。

利用哨兵减少判断，即使只是少了一次判断，在非常基础的底层函数中，性能也要做到极致。

### 对数时间复杂度
这是一种极其高效的时间复杂度，有的时候甚至比时间复杂度是常量级 O(1) 的算法还要高效，为什么这么说呢？

因为 logn 是一个非常“恐怖”的数量级，即便 n 非常非常大，对应的 logn 也很小。
比如 n 等于 2 的 32 次方，这个数很大了吧？大约是 42 亿。
也就是说，如果我们在 42 亿个数据中用二分查找一个数据，最多需要比较 32 次。

用大 O 标记法表示时间复杂度的时候，会省略掉常数、系数和低阶。
对于常量级时间复杂度的算法来说，O(1) 有可能表示的是一个非常大的常量值，比如 O(1000)、O(10000)。
所以，常量级时间复杂度的算法有时候可能还没有 O(logn) 的算法执行效率高。