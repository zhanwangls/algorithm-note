package Unit07_skiplist;

/**
 * 跳表
 * 它是一种各方面性能都比较优秀的动态数据结构。
 * 可以支持快速插入、删除、查找、甚至可以替代红黑树，写起来也不复杂。
 * 可以看作一种改进版的链表。
 *
 * 什么是跳表？
 * 对于一个链表来讲，即便数据是有序的，想在其中查找某个数据，也要从头遍历到尾，时间复杂度O(n)。
 * 想要提高查找效率，我们可以对链表建立一级索引，每两个结点提取一个到上一级，抽出来的那一级叫索引或索引层。
 * 如图所示：down表示down指针，指向下一级结点
 * 第一级索引： 1    ->   4    ->  7    ->   9    ->    13    ->    17
 *           down     down      down      down       down        down
 *           ↓         ↓         ↓         ↓          ↓            ↓
 * 原始链表：  1 -> 3 -> 4 -> 5 -> 7 -> 8 -> 9 -> 10 -> 13 -> 16 -> 17 -> 18
 * 如果要查找某个结点，比如16。现在索引层遍历，当遍历到索引值为13的结点时，发现下一节点为17，那要找的节点16肯定在这两个结点之间。
 * 通过索引层节点的down指针，下降到原始层，继续遍历，只要再遍历2个结点，就可以找到16这个节点了。原先需要遍历10个，现在只需遍历7个节点。
 * 一次类推，我们还可以再往上加更多层级索引，遍历的效率会更高。
 * 当n比较大的时候，这个效率会越明显。
 *
 * 时间复杂度：O(logn)
 * 首先来看，链表有n个数据，会有多少级索引：第 k 级索引的结点个数是第 k-1 级索引的结点个数的 1/2，那第 k级索引结点的个数就是 n/(2k)。
 * 假设索引有 h 级，最高级的索引有 2 个结点。通过上面的公式，我们可以得到 n/(2h)=2，从而求得 h=log2n-1。如果包含原始链表这一层，整个跳表的高度就是 log2n。
 * 我们在跳表中查询某个数据的时候，如果每一层都要遍历 m 个结点，那在跳表中查询一个数据的时间复杂度就是 O(m*logn)。
 * 那这个 m 的值是多少呢？按照前面这种索引结构，我们每一级索引都最多只需要遍历 3 个结点，也就是说 m=3。为什么呢？
 * 假设我们要查找的数据是 x，在第 k 级索引中，我们遍历到 y 结点之后，发现 x 大于 y，小于后面的结点 z，所以我们通过 y 的 down 指针，从第 k 级索引下降到第 k-1 级索引。
 * 在第 k-1 级索引中，y 和 z 之间只有 3 个结点（包含 y 和 z），所以，我们在 K-1 级索引中最多只需要遍历 3 个结点，依次类推，每一级索引都最多只需要遍历 3 个结点。
 *
 * 空间复杂度：O(n)
 * 数据大小为n，索引节点总和为：n/2+n/4+n/8+...+2 = n-2。即需要额外n个空间，空间复杂度O(n)。
 * 如果每隔3个节点抽出一个到上级索引，会不会降低空间复杂度呢？
 * 根据等比求和公式：n/3+n/9+n/27+...+1 = n/2。少了一半节点，空间复杂度依然是O(n)。
 * 其实，在软件开发中，不必太在意索引的额外存储空间，因为原始链表中存储的可能是很大的对象，而索引节点只需要存储关键值和几个指针，
 * 当对象比索引节点大很多时，索引占用的额外空间就可以忽略了。
 *
 * 插入和删除：O(logn)
 * 支持高效的动态插入和删除。
 * 链表中一旦定位好要插入数据的位置，插入的时间时间复杂度就是O(1)，而跳表查找一个节点的时间复杂度是O(logn)
 * 删除操作，除了要删除原始链表中的结点，还要删除索引中的。
 *
 * 跳表索引动态更新：
 * 我们不断插入数据时，如果不更新索引，就会出现某2个索引节点之间数据非常多的情况。极端情况下，还会退化成单链表。
 * 红黑树、AVL树是通过左右旋的方式保持左右子树大小平衡，跳表是通过随机函数来维护平衡性。
 * 通过一个随机函数，来决定将这个结点插入到哪几级索引中，比如随机函数生成了K值，我们就将这个结点添加到第1级到第K级这K级索引中。
 * 随机函数的选择也很有讲究。要从概率上讲，保证跳表的索引大小和数据大小平衡性。
 *
 */
public class SkipList {

    public SkipList() {

    }

    public static void main(String[] args) {

    }
}
